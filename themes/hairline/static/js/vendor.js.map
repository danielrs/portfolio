{"version":3,"sources":["bower_components/typing.js/dist/typing.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../static/js/vendor.js","sourcesContent":["(function() {\n  'use strict';\n\n  var globals = typeof global === 'undefined' ? self : global;\n  if (typeof globals.require === 'function') return;\n\n  var modules = {};\n  var cache = {};\n  var aliases = {};\n  var has = {}.hasOwnProperty;\n\n  var expRe = /^\\.\\.?(\\/|$)/;\n  var expand = function(root, name) {\n    var results = [], part;\n    var parts = (expRe.test(name) ? root + '/' + name : name).split('/');\n    for (var i = 0, length = parts.length; i < length; i++) {\n      part = parts[i];\n      if (part === '..') {\n        results.pop();\n      } else if (part !== '.' && part !== '') {\n        results.push(part);\n      }\n    }\n    return results.join('/');\n  };\n\n  var dirname = function(path) {\n    return path.split('/').slice(0, -1).join('/');\n  };\n\n  var localRequire = function(path) {\n    return function expanded(name) {\n      var absolute = expand(dirname(path), name);\n      return globals.require(absolute, path);\n    };\n  };\n\n  var initModule = function(name, definition) {\n    var hot = hmr && hmr.createHot(name);\n    var module = {id: name, exports: {}, hot: hot};\n    cache[name] = module;\n    definition(module.exports, localRequire(name), module);\n    return module.exports;\n  };\n\n  var expandAlias = function(name) {\n    return aliases[name] ? expandAlias(aliases[name]) : name;\n  };\n\n  var _resolve = function(name, dep) {\n    return expandAlias(expand(dirname(name), dep));\n  };\n\n  var require = function(name, loaderPath) {\n    if (loaderPath == null) loaderPath = '/';\n    var path = expandAlias(name);\n\n    if (has.call(cache, path)) return cache[path].exports;\n    if (has.call(modules, path)) return initModule(path, modules[path]);\n\n    throw new Error(\"Cannot find module '\" + name + \"' from '\" + loaderPath + \"'\");\n  };\n\n  require.alias = function(from, to) {\n    aliases[to] = from;\n  };\n\n  var extRe = /\\.[^.\\/]+$/;\n  var indexRe = /\\/index(\\.[^\\/]+)?$/;\n  var addExtensions = function(bundle) {\n    if (extRe.test(bundle)) {\n      var alias = bundle.replace(extRe, '');\n      if (!has.call(aliases, alias) || aliases[alias].replace(extRe, '') === alias + '/index') {\n        aliases[alias] = bundle;\n      }\n    }\n\n    if (indexRe.test(bundle)) {\n      var iAlias = bundle.replace(indexRe, '');\n      if (!has.call(aliases, iAlias)) {\n        aliases[iAlias] = bundle;\n      }\n    }\n  };\n\n  require.register = require.define = function(bundle, fn) {\n    if (bundle && typeof bundle === 'object') {\n      for (var key in bundle) {\n        if (has.call(bundle, key)) {\n          require.register(key, bundle[key]);\n        }\n      }\n    } else {\n      modules[bundle] = fn;\n      delete cache[bundle];\n      addExtensions(bundle);\n    }\n  };\n\n  require.list = function() {\n    var list = [];\n    for (var item in modules) {\n      if (has.call(modules, item)) {\n        list.push(item);\n      }\n    }\n    return list;\n  };\n\n  var hmr = globals._hmr && new globals._hmr(_resolve, require, modules, cache);\n  require._cache = cache;\n  require.hmr = hmr && hmr.wrap;\n  require.brunch = true;\n  globals.require = require;\n})();\n\n(function() {\nvar global = typeof window === 'undefined' ? this : window;\nvar __makeRelativeRequire = function(require, mappings, pref) {\n  var none = {};\n  var tryReq = function(name, pref) {\n    var val;\n    try {\n      val = require(pref + '/node_modules/' + name);\n      return val;\n    } catch (e) {\n      if (e.toString().indexOf('Cannot find module') === -1) {\n        throw e;\n      }\n\n      if (pref.indexOf('node_modules') !== -1) {\n        var s = pref.split('/');\n        var i = s.lastIndexOf('node_modules');\n        var newPref = s.slice(0, i).join('/');\n        return tryReq(name, newPref);\n      }\n    }\n    return none;\n  };\n  return function(name) {\n    if (name in mappings) name = mappings[name];\n    if (!name) return;\n    if (name[0] !== '.' && pref) {\n      var val = tryReq(name, pref);\n      if (val !== none) return val;\n    }\n    return require(name);\n  }\n};\nrequire.register(\"src/typing.js\", function(exports, require, module) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _util = require('./util');\n\nvar DEFAULT_SETTINGS = {\n\tsentences: ['Hello typing.js'],\n\tcaretChar: '_',\n\tcaretClass: 'typingjs__caret',\n\n\tignoreContent: false,\n\tignorePrefix: false,\n\ttypeDelay: 50,\n\tsentenceDelay: 750,\n\thumanize: true,\n\n\tonType: undefined,\n\tonBackspace: undefined,\n\tonFinish: undefined,\n\tonSentenceFinish: undefined\n};\n\nvar Typing = {\n\tnew: function _new(selector, options) {\n\t\tvar elements = document.querySelectorAll(selector);\n\t\tthis.withElements(elements, options);\n\t},\n\n\twithElements: function withElements(elements, options) {\n\t\t// Settings.\n\t\tvar settings = (0, _util.merge)(DEFAULT_SETTINGS, options);\n\n\t\tArray.prototype.map.call(elements, function (el) {\n\t\t\t// Creates initial elements.\n\t\t\tvar initialText = settings.ignoreContent ? '' : el.textContent;\n\n\t\t\tvar content = document.createElement('span');\n\t\t\tcontent.className = 'typingjs__content';\n\t\t\tcontent.textContent = initialText;\n\n\t\t\tvar caret = document.createElement('caret');\n\t\t\tcaret.className = settings.caretClass;\n\t\t\tcaret.textContent = settings.caretChar;\n\n\t\t\tel.innerHTML = '';\n\t\t\tel.appendChild(content);\n\t\t\tel.appendChild(caret);\n\n\t\t\t// Starts progress here.\n\t\t\tvar sentencesLeft = settings.sentences.slice();\n\n\t\t\tfunction typeSentence(typer) {\n\t\t\t\t// Reads next iteration of the typing animation.\n\t\t\t\tvar _typer = typer(),\n\t\t\t\t    current = _typer.current,\n\t\t\t\t    isType = _typer.isType,\n\t\t\t\t    isBackspace = _typer.isBackspace,\n\t\t\t\t    isDone = _typer.isDone;\n\n\t\t\t\tcontent.textContent = current;\n\n\t\t\t\tif (isDone) {\n\t\t\t\t\tif ((0, _util.isFunction)(settings.onSentenceFinish)) settings.onSentenceFinish.call(this_);\n\t\t\t\t\ttypeArray();\n\t\t\t\t} else {\n\t\t\t\t\t// Callbacks.\n\t\t\t\t\tif (isType && (0, _util.isFunction)(settings.onType)) settings.onType.call(this_);\n\t\t\t\t\tif (isBackspace && (0, _util.isFunction)(settings.onBackspace)) settings.onBackspace.call(this_);\n\n\t\t\t\t\t// Next step\n\t\t\t\t\tvar humanTimeout = settings.typeDelay;\n\t\t\t\t\tif (settings.humanize) humanTimeout = (0, _util.noise)(settings.typeDelay, settings.typeDelay);\n\t\t\t\t\tsetTimeout(typeSentence, humanTimeout, typer);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction typeArray() {\n\t\t\t\tvar targetStr = (0, _util.head)(sentencesLeft);\n\t\t\t\tsentencesLeft = (0, _util.tail)(sentencesLeft);\n\t\t\t\tif (targetStr !== undefined) {\n\t\t\t\t\tvar typer = (0, _util.makePrefixTyper)(content.textContent, targetStr);\n\t\t\t\t\tif (settings.ignorePrefix) {\n\t\t\t\t\t\ttyper = (0, _util.makeTyper)(content.textContent, targetStr, function (curr) {\n\t\t\t\t\t\t\treturn curr.length == 0;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tsetTimeout(typeSentence, settings.sentenceDelay, typer);\n\t\t\t\t} else if ((0, _util.isFunction)(settings.onFinish)) {\n\t\t\t\t\tsettings.onFinish.call(this_);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttypeArray();\n\t\t});\n\t}\n};\n\nif (typeof jQuery != 'undefined') {\n\t(function ($) {\n\t\t$.fn.typing = function (options) {\n\t\t\tTyping.withElements(this.get(), options);\n\t\t};\n\t})(jQuery);\n}\n\nwindow.Typing = Typing;\nexports.default = Typing;\n\n});\n\nrequire.register(\"src/util.js\", function(exports, require, module) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.merge = merge;\nexports.isFunction = isFunction;\nexports.isArray = isArray;\nexports.head = head;\nexports.tail = tail;\nexports.strTail = strTail;\nexports.strHead = strHead;\nexports.strLast = strLast;\nexports.strDrop = strDrop;\nexports.strDropTail = strDropTail;\nexports.strIntersect = strIntersect;\nexports.noise = noise;\nexports.isPrefix = isPrefix;\nexports.isEmpty = isEmpty;\nexports.makeTyper = makeTyper;\nexports.makePrefixTyper = makePrefixTyper;\n// Merges two objects.\nfunction merge() {\n\tvar merged = {};\n\tfor (var i = 0; i < arguments.length; i++) {\n\t\tvar obj = arguments[i];\n\t\tfor (var attr in obj) {\n\t\t\tmerged[attr] = obj[attr];\n\t\t}\n\t}\n\treturn merged;\n}\n\n// Checks if the given object is a function. Taken from underscorejs source code.\nfunction isFunction(obj) {\n\treturn !!(obj && obj.constructor && obj.call && obj.apply);\n}\n\n// Checks if the given object is an array.\nfunction isArray(obj) {\n\treturn toString(obj) === \"[object Array]\";\n}\n\n// Returns the first element of the array.\nfunction head(array) {\n\treturn array[0];\n}\n\n// Returns the same array skipping the first element.\nfunction tail(array) {\n\treturn array.slice(1);\n}\n\n// Drops the first character of the string and returns the rest.\nfunction strTail(str) {\n\treturn str.substring(1, str.length);\n}\n\n// Returns the first character of the string.\nfunction strHead(str) {\n\treturn str[0];\n}\n\n// Return the last character of the string.\nfunction strLast(str) {\n\treturn str[str.length - 1];\n}\n\n// Drops the given number of characters from the start of the string.\nfunction strDrop(string, n) {\n\treturn string.substr(n, string.length);\n}\n\n// Drops the given number of characters from the end of the string\nfunction strDropTail(string, n) {\n\treturn string.substr(0, string.length - n);\n}\n\n// Intersects the start of two strings.\nfunction strIntersect(a, b) {\n\tvar i;\n\tfor (i = 0; i < Math.min(a.length, b.length); i++) {\n\t\tif (a[i] != b[i]) break;\n\t}\n\treturn a.substr(0, i);\n}\n\n// Returns the original value with the given noise applied.\n// E.g. noise(x, 2) = x - 2 <= y <= x + 2\nfunction noise(x, delta) {\n\treturn Math.round(Math.random() * delta * 2 - delta) + x;\n}\n\n// Checks if the given prefix is prefix of target.\nfunction isPrefix(prefix, target) {\n\treturn target.substr(0, prefix.length) == prefix;\n}\n\n// Checks if the given string has length zero.\nfunction isEmpty(string) {\n\treturn string.length == 0;\n}\n\n// Creates a typer that deletes characters each time it\n// is called until predicate is true. After that, it appends\n// the characters of the given string one by one each time\n// it is called.\nfunction makeTyper(current, pending, predicate) {\n\tvar forward = current.length == 0 || predicate(current, pending);\n\tvar prevLength = current.length;\n\treturn function () {\n\t\tvar step = {\n\t\t\tcurrent: current,\n\t\t\tpending: pending,\n\t\t\tisType: current.length > prevLength,\n\t\t\tisBackspace: current.length < prevLength,\n\t\t\tisDone: forward && pending.length <= 0\n\t\t};\n\n\t\tprevLength = current.length;\n\t\tif (forward && pending.length > 0) {\n\t\t\tcurrent = current + head(pending);\n\t\t\tpending = tail(pending);\n\t\t} else if (!forward && current.length > 0) {\n\t\t\tcurrent = strDropTail(current, 1);\n\t\t}\n\t\tforward = forward || current.length == 0 || predicate(current, pending);\n\n\t\treturn step;\n\t};\n}\n\n// Creates a typer that deletes characters until current is a prefix\n// of target.\nfunction makePrefixTyper(current, target) {\n\tvar commonPrefix = strIntersect(current, target);\n\tvar pending = target.substr(commonPrefix.length, target.length);\n\treturn makeTyper(current, pending, function (curr) {\n\t\treturn curr == commonPrefix;\n\t});\n}\n\n});\n\n;require.register(\"___globals___\", function(exports, require, module) {\n  \n});})();require('___globals___');\n\nrequire('src/typing');\n//# sourceMappingURL=typing.js.map"]}